---
title: "Bikeshare data: preliminary analysis"
author: "Coach Skufca"
date: "2022-09-09"
output: html_notebook
---

A prelimiary look at bikeshare data, focused on Sep 2022 data from DC bikeshare.

Primary Data Source: https://s3.amazonaws.com/capitalbikeshare-data/index.html


## Load Packages

```{r}
library(tidyverse)
library(here)
library(janitor)
library(lubridate)
theme_set(theme_minimal())
```

## Data Load

```{r}
myfile=here("data_raw","202209-capitalbikeshare-tripdata.zip")
dfa=read_csv(myfile) %>% clean_names()
```

```{r}
dfa1=dfa %>%   mutate(duration=as.numeric((ended_at-started_at)/60),
         hour_of_day=hour(started_at),
         day_of_week=wday(started_at,label = T))
```

Summarize the dataframe to identify any data issues:

```{r}
skimr::skim(dfa1)
```

## Some Analysis

Duration

```{r}
dfa1 %>% 
  ggplot(aes(x=duration)) + geom_histogram(bins = 300)+facet_wrap(~day_of_week)
```


```{r}
dfa1 %>% filter(duration<100,duration>0) %>% 
  ggplot(aes(x=duration)) + geom_histogram(bins = 300)+facet_wrap(~day_of_week)
```


### Cleaning

```{r}
dfb=dfa1 %>% filter(duration>0)
```


```{r}
dfb %>% filter(mday(started_at)==3,duration<60) %>% ggplot(aes(x=started_at,y=duration))+
  geom_point(alpha=.1)+
  ggtitle("Trip duration vs start time (September 3)")
```


### Riders vs time

Let’s try to construct a dataframe that could track number of riders (at any instant in time), where we will assume (not reasonably) that there were no riders at 00:00.

I will develop (and test) the logic on a small set of data.
A small dataset works fast and is easy to read.
Once we build the logic for the small set, it is easy to generalize.

The slice_sample command below takes a random sample of 100 rows. So … my experimental dataframe, dfe, limits to the 3rd day of the month, and only 100 rows.

```{r}
dfe=dfb %>% filter(mday(started_at)==3) %>% slice_sample(n=100)
```

#### Designing an algorithm


Now lets build a process. I will proceed step by step (copying and pasting to add one new step to my process until I get what I want).

I think we only need start and end times.


```{r}
dfe %>% select(start=started_at,end=ended_at)
```

Create a long dataset


```{r}
dfe %>% select(start=started_at,end=ended_at) %>%
  pivot_longer(start:end) 
```

Pick good names and then, order by time.

```{r}
dfe %>% select(start=started_at,end=ended_at) %>%
  pivot_longer(start:end, names_to="type",values_to="t") %>% arrange(t)
```

I want to build a counter to track riders, where each “start” increases the count, and each end “decrease” the count.

Additionally, I will want my to arrange my rows using my time t column.

```{r}
dfe %>% select(start=started_at,end=ended_at) %>%
  pivot_longer(start:end, names_to="type",values_to="t") %>% arrange(t) %>%
  mutate(increment=case_when(
   type=="start"~1,
   type=="end" ~ -1
  )) 
```

Now lets cummulative sum that column.

```{r}
dfe %>% select(start=started_at,end=ended_at) %>%
  pivot_longer(start:end, names_to="type",values_to="t") %>% arrange(t) %>%
  mutate(increment=case_when(
   type=="start"~1,
   type=="end" ~ -1
  )) %>%
  mutate(riders=cumsum(increment))
```


I think that is what I need. I will visualize (using a step plot) to see if it makes sense. I simply … continue the pipe.

```{r}
dfe %>% select(start=started_at,end=ended_at) %>%
  pivot_longer(start:end, names_to="type",values_to="t") %>% arrange(t) %>%
  mutate(increment=case_when(
   type=="start"~1,
   type=="end" ~ -1
  )) %>%
  mutate(riders=cumsum(increment)) %>% 
  ggplot(aes(t,riders)) + geom_step()
```

### Analyzing without sampling -- bigger data

Now … let’s examine all the data for Sep 3rd. I simply need to drop in the dataframe for Sep 3rd without doing the steps that select a random sample, but otherwise using the exact commands developed above.



```{r}
dfb %>% filter(mday(started_at)==1) %>%
  select(start=started_at,end=ended_at) %>%
  pivot_longer(start:end, names_to="type",values_to="t") %>% arrange(t) %>%
  mutate(increment=case_when(
   type=="start"~1,
   type=="end" ~ -1
  )) %>%
  mutate(riders=cumsum(increment)) %>% 
  ggplot(aes(t,riders)) + geom_step()
```


We could look at the whole dataset. All we have to do is not do that filtering step … and let the axis cover the whole range.


```{r}
dfb %>% 
  select(start=started_at,end=ended_at) %>%
  pivot_longer(start:end, names_to="type",values_to="t") %>% arrange(t) %>%
  mutate(increment=case_when(
   type=="start"~1,
   type=="end" ~ -1
  )) %>%
  mutate(riders=cumsum(increment)) %>% 
  ggplot(aes(t,riders)) + geom_step()
```

I think this is interesting, but I think I can improve using faceting, to separate out for each day of the month. I will facet by 7 columns so that days of the week are aligned. For these facets, I use the option “free_x” as each facet is covering a different time range.

It also turns out that the datset includes information from 1,2,3,.. October, which screws things up a bit, so … I filter to only the month of August.

```{r}
dfb %>% 
  filter(month(started_at)==9,month(ended_at)==9) %>%
  select(start=started_at,end=ended_at) %>%
  pivot_longer(start:end, names_to="type",values_to="t") %>% arrange(t) %>%
  mutate(increment=case_when(
   type=="start"~1,
   type=="end" ~ -1
  )) %>%
  mutate(riders=cumsum(increment)) %>% 
  ggplot(aes(t,riders)) + geom_step() +
  facet_wrap(~mday(t),scales = "free_x",ncol = 7)
```

### Separating by bike type

To consider by type of bike, we will need “cumsum” to be working separately on "bike type". Which means:

We have to include that variable in the dataset, and
We will need to group on that variable
For this visualization, although I do the compuation for the whole month, I will show only the first 7 days of September.


```{r}
dfb %>% 
  filter(month(started_at)==9,month(ended_at)==9) %>%
 select(rideable_type,start=started_at,end=ended_at) %>%
  pivot_longer(start:end, names_to="type",values_to="t") %>% arrange(t) %>%
  mutate(increment=case_when(
   type=="start"~1,
   type=="end" ~ -1
  )) %>%
  group_by(rideable_type) %>%
  mutate(riders=cumsum(increment)) %>% filter(mday(t)<=7) %>%
    ggplot(aes(t,riders,color=rideable_type)) + geom_step() +
  facet_wrap(~mday(t),scales = "free_x",ncol = 7)

# facet_wrap(~wday(t,label = T),scales = "free_x",ncol = 7)
```

```{r}
dfb %>% 
  filter(month(started_at)==9,month(ended_at)==9) %>%
 select(member_casual,start=started_at,end=ended_at) %>%
  pivot_longer(start:end, names_to="type",values_to="t") %>% arrange(t) %>%
  mutate(increment=case_when(
   type=="start"~1,
   type=="end" ~ -1
  )) %>%
  group_by(member_casual) %>%
  mutate(riders=cumsum(increment)) %>% filter(mday(t)<=30) %>%
    ggplot(aes(t,riders,color=member_casual)) + geom_step() +
  facet_wrap(~mday(t),scales = "free_x",ncol = 7)

# facet_wrap(~wday(t,label = T),scales = "free_x",ncol = 7)
```
